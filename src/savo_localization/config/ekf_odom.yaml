# Robot Savo â€” savo_localization/config/ekf_odom.yaml
# ---------------------------------------------------
# robot_localization EKF configuration (ODOM mode).
#
# Purpose:
# - Fuse wheel odometry (rear encoders -> /wheel/odom) with IMU (/imu/data)
# - Publish /odometry/filtered for Nav2
# - Publish TF: odom -> base_link (single TF authority for odom->base)
#
# Notes (mecanum + 2 rear encoders):
# - Rear-only encoders can reliably provide: x displacement, vx, yaw rate (wz) (approx)
# - Rear-only encoders cannot observe: vy and true y displacement -> DO NOT fuse y from wheel odom
# - IMU stabilizes yaw + yaw rate
# - Global drift correction comes later via AMCL/SLAM providing map->odom

ekf_filter_node:
  ros__parameters:

    # -------------------------
    # Core
    # -------------------------
    frequency: 50.0
    sensor_timeout: 0.30
    two_d_mode: true

    transform_time_offset: 0.0
    transform_timeout: 0.10

    # Publish filtered output + TF
    publish_tf: true
    publish_acceleration: false
    print_diagnostics: true

    # -------------------------
    # Frames
    # -------------------------
    # map_frame is required by the node even in odom-only mode.
    map_frame: "map"
    odom_frame: "odom"
    base_link_frame: "base_link"
    world_frame: "odom"   # ODOM EKF: world frame is odom

    # Optional: if you use base_footprint in your TF tree, swap base_link_frame.
    # base_link_frame: "base_footprint"

    # -------------------------
    # Input 1: Wheel odometry
    # -------------------------
    odom0: "/wheel/odom"

    # IMPORTANT:
    # - Disable y (and vy) because rear-only encoders cannot observe lateral motion (mecanum).
    # - Keep x, yaw, vx, vyaw enabled.
    odom0_config: [
      true,  false, false,   # x, y, z
      false, false, true,    # roll, pitch, yaw
      true,  false, false,   # vx, vy, vz
      false, false, true,    # vroll, vpitch, vyaw
      false, false, false    # ax, ay, az
    ]

    odom0_queue_size: 10
    odom0_nodelay: true
    odom0_differential: false
    odom0_relative: false

    # -------------------------
    # Input 2: IMU
    # -------------------------
    imu0: "/imu/data"

    # 2D fusion: yaw + yaw rate only
    imu0_config: [
      false, false, false,   # x, y, z
      false, false, true,    # roll, pitch, yaw
      false, false, false,   # vx, vy, vz
      false, false, true,    # vroll, vpitch, vyaw
      false, false, false    # ax, ay, az
    ]

    imu0_queue_size: 20
    imu0_nodelay: true

    # Keep false initially (typical for BNO055 orientation output).
    # If you later decide to trust only gyro integration, we can switch to imu0_differential: true.
    imu0_differential: false
    imu0_relative: false

    imu0_remove_gravitational_acceleration: true

    # -------------------------
    # Filter tuning (conservative defaults)
    # -------------------------
    # Safe starting point; tune later after validating sensor noise on real hardware.
    process_noise_covariance: [
      0.05, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      0,    0.05, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      0,    0,    0.1,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      0,    0,    0,    0.1,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0.1,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0.2,  0,    0,    0,    0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0.2,  0,    0,    0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0.2,  0,    0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0.3,  0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0.3,  0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0.3,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0.6,  0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0.6,  0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0.6,  0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0.6
    ]

    # Start with moderate uncertainty (not too confident)
    initial_estimate_covariance: [
      1.0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   1.0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   5.0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   5.0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   5.0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   1.0, 0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   1.0, 0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   1.0, 0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   1.0, 0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   1.0, 0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1.0, 0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2.0, 0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2.0, 0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2.0, 0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2.0
    ]